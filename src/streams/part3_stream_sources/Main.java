package streams.part3_stream_sources;

import java.util.*;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class Main {

    public static void main(String[] args) {

        // Use a collection - With ArrayList
        List<String> bingoPool = new ArrayList<>(75);

        int start = 1;
        for (char c: "BINGO".toCharArray()) {
            for (int i = start; i < (start + 15); i++) {
                bingoPool.add("" + c + i );
            }
            start += 15;
        }

        //shuffle and print the first 15
        Collections.shuffle(bingoPool);

        System.out.println("\n______________________________________");

        //Use variable in streams
        bingoPool.stream()
                .limit(15)
                .filter(s -> s.indexOf('G')== 0 || s.indexOf('O') == 0)
                .map(s-> s.charAt(0) + "-" + s.substring(1))
                .sorted()
                .forEach(s -> System.out.print(s + " "));



        System.out.println("\n______________________________________\n");

        //
        //
        //
        // Use a collection - With Array
        String[] strings = {"One","Two","Three"};

        //We can use a helper class on java.util.Arrays called streams on our strings []
        // Then use sorted as an intermediate operation and pass the reverseOrder comparator
       // The terminal operation is forEach and use method reference sout

        var firstStream = Arrays.stream(strings)
                .sorted(Comparator.reverseOrder());
                // .forEach(System.out::println);

        System.out.println("\n______________________________________\n");

        //
        //
        //
        // Using the static .of() method on the Stream Interface (java.util.Stream)
        // Takes a variable argument of any type

        var secondStream = Stream.of("Six","Five","Four")
                .map(String::toUpperCase);
               // .forEach(System.out::println);

        System.out.println("\n______________________________________\n");


        //
        //
        //
        // Using concat() that is another static method on the Stream Interface (java.util.Stream)
        // Produces a single stream, from two streams produced from diff sources

        Stream.concat(secondStream, firstStream)
                .map(s -> s.charAt(0) + " - " + s)
                .forEach(System.out::println);

        //
        //
        //
        // Using Map() collection with Streams
        // Map interface does not extend Collections interface and the Map
        // and it's implementing classes were sort in a category of their own
        // Map interface does not have a stream either but you can use any of
        // Map's collection views , keySet,entrySet , values to generate a stream to process
        // parts of a map
        System.out.println("\n______________________________________\n");

        Map<Character,int[]> myMap = new LinkedHashMap<>();
        int bingoIndex = 1;
        for (char c: "BINGO".toCharArray() ) {
                int[] numbers = new int[15];
                int labelNo = bingoIndex;
                Arrays.setAll(numbers,i -> i + labelNo);
                myMap.put(c , numbers);
                bingoIndex += 15;
        }

        //use a stream to make our map looks good
        myMap.entrySet()
                .stream()
                .map(e -> e.getKey() + " has range: "+ e.getValue()[0] + " - " + e.getValue()[e.getValue().length -1 ])
                .forEach(System.out::println);


        //
        //
        //
        // static <T> Stream<T> generate(Supplier<? extends T> s)
        // Using generate() that is another static method on the Stream Interface (java.util.Stream)
        // Takes a Supplier Functional - returns a value but does not take an argument
        // Returns an infinite sequential unordered stream where each element is generated by the provided Supplier.
        // This is suitable for generating constant streams, streams of random elements, etc.
        //limit to 10 integers
        System.out.println("\n________________ Stream.generate() ______________________\n");

        Random random = new Random();
        Stream.generate(() -> random.nextInt(2))
                .limit(10)
                .forEach(s -> System.out.print(s + " "));

        /*

         static <T> Stream<T> iterate(T seed, UnaryOperator<T> f)

         * Returns an infinite sequential ordered Stream produced by iterative application of a function f to an
         initial element seed, producing a Stream consisting of seed, f(seed), f(f(seed)), etc.

         * The first element (position 0) in the Stream will be the provided seed.

         * For n > 0, the element at position n, will be the result of applying the function f to the element at
           position n - 1.

         * The action of applying f for one element happens-before the action of applying f for subsequent elements.

         * For any given element the action may be performed in whatever thread the library chooses.

         - seed - starting value
         - UnaryOperator - special kind of function

         - use a method reference on a static method to Filter prime numbers only using Main::prime

         */

        System.out.println("\n_______________ IntStream.iterate() 1st 20_______________________\n");

        IntStream.iterate(1, n -> n +1)
                .filter(Main::isPrime)
                .limit(20)
                .forEach(s -> System.out.print(s + " "));


        System.out.println("\n_______________ IntStream.iterate() prime Nos < 100 _______________________\n");

        IntStream.iterate(1, n -> n +1)
                .limit(100)
                .filter(Main::isPrime)
                .forEach(s -> System.out.print(s + " "));


        /*

            overloaded version

            static <T> Stream<T> iterate(T seed,
                                            Predicate<? super T> hasNext,
                                             UnaryOperator<T> next)

         * The first uses an infinite stream limited by an intermediate operation .i.e limit(20)

         * This one uses a finite stream , it's limiting condition declared as the 2nd param

         - use a method reference on a static method to Filter prime numbers only using Main::prime

         */

        System.out.println("\n_______________ IntStream.iterate() prime Nos < 100  - using the overloaded version _______________________\n");

        IntStream.iterate(1, n -> n <= 100 , n -> n +1)
                .filter(Main::isPrime)
                .forEach(s -> System.out.print(s + " "));


        /*

            There are 2 additional methods which we can use on any of the primitive streams
            So on IntStream like above or DoubleStream or LongStream

            These are :-

                -  range(int startInclusive , int endExclusive)

                -  range(int startInclusive , int endInclusive)
         */

        System.out.println("\n_______________ IntStream.range( int start(inclusive), int end(exclusive)) _______________________\n");

        IntStream.range(1, 100)
                .filter(Main::isPrime)
                .forEach(s -> System.out.print(s + " "));


        System.out.println("\n_______________ IntStream.rangeClosed( int start(inclusive), int end(inclusive)) _______________________\n");

        IntStream.rangeClosed(1, 100)
                .filter(Main::isPrime)
                .forEach(s -> System.out.print(s + " "));


    }

    // print prime numbers
    private static boolean isPrime(int wholeNumber){
        if(wholeNumber <= 2)
            return (wholeNumber == 2);
        for (int divisor = 2; divisor < wholeNumber; divisor++) {
            if (wholeNumber % divisor == 0)
                return false;
        }
        return true;
    }
}
